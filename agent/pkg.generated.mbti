// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/maria/agent"

import(
  "moonbitlang/maria/context"
  "moonbitlang/maria/conversation"
  "moonbitlang/maria/event"
  "moonbitlang/maria/model"
  "moonbitlang/maria/openai"
  "moonbitlang/maria/pino"
  "moonbitlang/maria/token"
  "moonbitlang/maria/tool"
)

// Values
async fn new(@model.Model, cwd~ : StringView, session_manager? : @conversation.Manager) -> Agent

// Errors

// Types and methods
pub struct Agent {
  logger : @pino.Logger
  cwd : String
  model : @model.Model
  tools : Map[String, @tool.Tool[Unit]]
  history : @conversation.Conversation
  mut queue : Array[@openai.ChatCompletionMessageParam]
  event_target : @event.Target[Event, EventContext]
  token_counter : @token.Counter
  context_pruner : @context.Pruner
  session_manager : @conversation.Manager
}
fn Agent::add_listener(Self, Event, async (EventContext) -> Unit) -> Unit
fn Agent::add_message(Self, @openai.ChatCompletionMessageParam) -> Unit
fn[T] Agent::add_tool(Self, @tool.Tool[T], T) -> Unit
fn Agent::close(Self) -> Unit
async fn Agent::start(Self) -> Unit

pub(all) enum Event {
  ConversationStart
  ConversationEnd
  PreToolCall
  PostToolCall
  TokenCounted
  RequestCompleted
}
impl Eq for Event
impl Hash for Event

pub struct EventContext {
  usage : @openai.CompletionUsage?
  message : @openai.ChatCompletionMessage?
  origin_token_count : Int?
  pruned_token_count : Int?
  tool_call : @openai.ChatCompletionMessageToolCall?
  tool_call_result : @tool.Result?
}

// Type aliases

// Traits

